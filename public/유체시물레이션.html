<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lattice Boltzmann Simulation</title>
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            margin: 0;
            padding: 0;
        }
        canvas {
            border: 1px solid black;
            width: 1000px;
        }
        .comment-section {
            position: fixed;
            top: 0;
            left: -400px;
            width: 350px;
            height: 100%;
            background-color: #f8f8f8;
            box-shadow: -2px 0 5px rgba(0, 0, 0, 0.1);
            transition: left 0.3s ease-in-out;
            z-index: 10000;
            display: flex;
            flex-direction: column;
        }
        .comment-section.open {
            left: 0;
        }
        .comment-header {
            padding: 10px;
            color: #000000;
            font-size: 20px;
            font-weight: 700;
            text-align: center;
        }
        .comment-body {
            padding: 10px;
            flex-grow: 1;
            overflow-y: auto;
        }
        .comment {
            background-color: #fff;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }
        .comment p {
            margin: 0 0 10px 0;
            line-height: 1.4;
        }
        .comment-input {
            width: calc(100% - 80px);
            padding: 15px;
            margin: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            resize: vertical;
            min-height: 100px;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        .comment-submit {
            width: calc(100% - 50px);
            padding: 15px;
            margin: 0 20px 20px;
            background-color: #4CAF50;
            color: #fff;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .comment-submit:hover {
            background-color: #45a049;
        }
        .eotrmf {
            position: fixed;
            top: 10px;
            right: 30px;
            font-size: 24px;
            color: #000000;
            width: 50px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .home-button {
            position: fixed;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <canvas id="simulationCanvas"></canvas>
    <div id="progress"></div>
    <div class="eotrmf">üí¨</div>
    <div class="comment-section" id="commentSection">
        <div class="comment-header">ÎåìÍ∏Ä</div>
        <hr>
        <div class="comment-body" id="commentBody">
            {% for comment in comments %}
            <div class="comment">
                <p>{{ comment.content }}</p>
            </div>
            {% endfor %}
        </div>
        {% if islogin == True %}
        <textarea class="comment-input" id="commentInput" placeholder="ÎåìÍ∏ÄÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî..."></textarea>
        <button class="comment-submit" onclick="addcomment()">ÎåìÍ∏Ä Ï∂îÍ∞Ä</button>
        {% endif %}
    </div>
    <a href="/index" class="home-button">ÎèåÏïÑÍ∞ÄÍ∏∞</a>
    <script>
        const Re = 200;
        const maxIter = 500000;
        const nx = 105, ny = 45;
        const ly = ny - 1;
        const uLB = 0.01;
        const cx = Math.floor(nx / 6), cy = Math.floor(ny / 2), r = Math.floor(ny / 11);
        const nulb = 1 * uLB * r / Re;
        const omega = 1 / (3 * nulb + 0.5);

        const ci = [
            [1, 0], [0, 1], [-1, 0], [0, -1],
            [1, 1], [-1, 1], [-1, -1], [1, -1],
            [0, 0]
        ];

        const wi = [1/9, 1/9, 1/9, 1/9, 1/36, 1/36, 1/36, 1/36, 4/9];

        const colLeft = [0, 4, 7];
        const colRest = [1, 3, 8];
        const colRight = [2, 5, 6];
        const colWall = [2, 3, 0, 1, 5, 6, 7, 6, 8];

        function createArray(dimensions) {
            if (dimensions.length > 1) {
                return Array.from({ length: dimensions[0] }, () => 
                    createArray(dimensions.slice(1)));
            } else {
                return new Array(dimensions[0]).fill(0);
            }
        }

        function macroscopic(fin) {
            const rho = createArray([nx, ny]);
            const u = createArray([2, nx, ny]);

            for (let x = 0; x < nx; x++) {
                for (let y = 0; y < ny; y++) {
                    rho[x][y] = fin.reduce((sum, f) => sum + f[x][y], 0);
                    for (let i = 0; i < 9; i++) {
                        u[0][x][y] += ci[i][0] * fin[i][x][y];
                        u[1][x][y] += ci[i][1] * fin[i][x][y];
                    }
                    u[0][x][y] /= rho[x][y];
                    u[1][x][y] /= rho[x][y];
                }
            }
            return [rho, u];
        }

        function equilibrium(rho, u) {
            const feq = createArray([9, nx, ny]);
            for (let x = 0; x < nx; x++) {
                for (let y = 0; y < ny; y++) {
                    const usqr = (3/2) * (u[0][x][y]**2 + u[1][x][y]**2);
                    for (let i = 0; i < 9; i++) {
                        const cu = 3 * (ci[i][0] * u[0][x][y] + ci[i][1] * u[1][x][y]);
                        feq[i][x][y] = rho[x][y] * wi[i] * (1 + cu + 0.5 * cu**2 - usqr);
                    }
                }
            }
            return feq;
        }

        const obstacle = createArray([nx, ny]);
        for (let x = 0; x < nx; x++) {
            for (let y = 0; y < ny; y++) {
                obstacle[x][y] = ((x - cx)**2 + (y - cy)**2 <= r**2);
            }
        }

        const u = createArray([2, nx, ny]);
        for (let x = 0; x < nx; x++) {
            for (let y = 0; y < ny; y++) {
                u[0][x][y] = uLB;
            }
        }

        let fin = equilibrium(createArray([nx, ny]).map(row => row.fill(1)), u);

        const canvas = document.getElementById('simulationCanvas');
        canvas.width = nx;
        canvas.height = ny;
        const ctx = canvas.getContext('2d');

        function updateSimulation() {
            for (let i = 0; i < 100; i++) {  // Run 100 iterations per frame
                // Right wall: outflow condition
                for (let i of colRight) {
                    for (let y = 0; y < ny; y++) {
                        fin[i][nx-1][y] = fin[i][nx-2][y];
                    }
                }

                // Compute macroscopic variables
                let [rho, u] = macroscopic(fin);

                // Left wall: inflow condition
                for (let y = 0; y < ny; y++) {
                    u[0][0][y] = uLB;
                    u[1][0][y] = 0;
                    rho[0][y] = 1 / (1 - u[0][0][y]) * (
                        colRest.reduce((sum, i) => sum + fin[i][0][y], 0) +
                        2 * colRight.reduce((sum, i) => sum + fin[i][0][y], 0)
                    );
                }

                // Compute equilibrium
                const feq = equilibrium(rho, u);

                // Left wall: Zou/He boundary condition
                for (let i of colLeft) {
                    for (let y = 0; y < ny; y++) {
                        fin[i][0][y] = feq[i][0][y] + fin[colRight[colLeft.indexOf(i)]][0][y] - feq[colRight[colLeft.indexOf(i)]][0][y];
                    }
                }

                // Collision step
                const fout = createArray([9, nx, ny]);
                for (let i = 0; i < 9; i++) {
                    for (let x = 0; x < nx; x++) {
                        for (let y = 0; y < ny; y++) {
                            fout[i][x][y] = fin[i][x][y] - omega * (fin[i][x][y] - feq[i][x][y]);
                            if (obstacle[x][y]) {
                                fout[i][x][y] = fin[colWall[i]][x][y];
                            }
                        }
                    }
                }

                // Streaming step
                for (let i = 0; i < 9; i++) {
                    for (let x = 0; x < nx; x++) {
                        for (let y = 0; y < ny; y++) {
                            const newX = (x + ci[i][0] + nx) % nx;
                            const newY = (y + ci[i][1] + ny) % ny;
                            fin[i][newX][newY] = fout[i][x][y];
                        }
                    }
                }
            }

            // Visualization
            const [rho, u] = macroscopic(fin);
            const imageData = ctx.createImageData(nx, ny);
            for (let x = 0; x < nx; x++) {
                for (let y = 0; y < ny; y++) {
                    const velocity = Math.sqrt(u[0][x][y]**2 + u[1][x][y]**2);
                    const index = (y * nx + x) * 4;
                    imageData.data[index] = velocity * 10000;  // Red channel
                    imageData.data[index + 3] = 255;  // Alpha channel
                }
            }
            ctx.putImageData(imageData, 0, 0);

            requestAnimationFrame(updateSimulation);
        }

        updateSimulation();

        document.querySelector('.eotrmf').addEventListener('click', () => {
            document.getElementById('commentSection').classList.toggle('open');
        });

        function addcomment() {
            const commentSection = document.getElementById('commentSection');
            const commentInput = document.getElementById('commentInput');
            const commentBody = document.getElementById('commentBody');
            const postId = 7; // Ïã§Ï†ú Ìè¨Ïä§Ìä∏ IDÎ°ú ÍµêÏ≤¥Ìï¥Ïïº Ìï®

            const newCommentText = commentInput.value.trim();
            if (newCommentText === '') return; // Îπà ÎåìÍ∏ÄÏùÄ Ï∂îÍ∞ÄÌïòÏßÄ ÏïäÏùå

            // ÎåìÍ∏ÄÏùÑ Ï∂îÍ∞ÄÌïòÎäî ÏöîÏ≤≠
            fetch(`/comments/${postId}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: new URLSearchParams({
                    content: newCommentText
                })
            })
            .then(response => {
                if (response.ok) {
                    return response.json();
                } else {
                    throw new Error('ÎåìÍ∏Ä Ï∂îÍ∞ÄÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.');
                }
            })
            .then(newComment => {
                // ÎåìÍ∏Ä Ï∂îÍ∞Ä ÏÑ±Í≥µ Ïãú ÎåìÍ∏ÄÏùÑ DOMÏóê Ï∂îÍ∞Ä
                const commentElement = document.createElement('div');
                commentElement.className = 'comment';
                commentElement.innerHTML = `<p>${newComment.content}</p>`;
                commentBody.appendChild(commentElement);
                commentInput.value = ''; // ÏûÖÎ†• ÌïÑÎìú Ï¥àÍ∏∞Ìôî
            })
            .catch(error => {
                console.error('ÎåìÍ∏Ä Ï∂îÍ∞Ä Ï§ë Ïò§Î•ò Î∞úÏÉù:', error);
                alert('ÎåìÍ∏Ä Ï∂îÍ∞ÄÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.');
            });
        }
    </script>
</body>
</html>